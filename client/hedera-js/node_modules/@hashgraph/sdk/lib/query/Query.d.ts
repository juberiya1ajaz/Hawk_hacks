/**
 * @param {string} logId
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {?ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<HashgraphProto.proto.ITransaction>}
 */
export function _makePaymentTransaction(logId: string, paymentTransactionId: TransactionId, nodeId: AccountId, operator: ClientOperator | null, paymentAmount: Hbar): Promise<HashgraphProto.proto.ITransaction>;
/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../PublicKey.js").default} PublicKey
 */
/**
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */
/**
 * @type {Map<HashgraphProto.proto.Query["query"], (query: HashgraphProto.proto.IQuery) => Query<*>>}
 */
export const QUERY_REGISTRY: Map<"getByKey" | "getBySolidityID" | "contractCallLocal" | "contractGetInfo" | "contractGetBytecode" | "ContractGetRecords" | "cryptogetAccountBalance" | "cryptoGetAccountRecords" | "cryptoGetInfo" | "cryptoGetLiveHash" | "cryptoGetProxyStakers" | "fileGetContents" | "fileGetInfo" | "transactionGetReceipt" | "transactionGetRecord" | "transactionGetFastRecord" | "consensusGetTopicInfo" | "networkGetVersionInfo" | "tokenGetInfo" | "scheduleGetInfo" | "tokenGetAccountNftInfos" | "tokenGetNftInfo" | "tokenGetNftInfos" | "networkGetExecutionTime" | undefined, (query: HashgraphProto.proto.IQuery) => Query<any>>;
/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @abstract
 * @template OutputT
 * @augments {Executable<HashgraphProto.proto.IQuery, HashgraphProto.proto.IResponse, OutputT>}
 */
export default class Query<OutputT> extends Executable<HashgraphProto.proto.IQuery, HashgraphProto.proto.IResponse, OutputT> {
    /**
     * @template T
     * @param {Uint8Array} bytes
     * @returns {Query<T>}
     */
    static fromBytes<T>(bytes: Uint8Array): Query<T>;
    constructor();
    /** @type {?TransactionId} */
    _paymentTransactionId: TransactionId | null;
    /** @type {HashgraphProto.proto.ITransaction[]} */
    _paymentTransactions: HashgraphProto.proto.ITransaction[];
    /** @type {?Hbar} */
    _queryPayment: Hbar | null;
    /** @type {?Hbar} */
    _maxQueryPayment: Hbar | null;
    _timestamp: number;
    /**
     * @returns {Uint8Array}
     */
    toBytes(): Uint8Array;
    /**
     * Set an explicit payment amount for this query.
     *
     * The client will submit exactly this amount for the payment of this query. Hedera
     * will not return any remainder.
     *
     * @param {Hbar} queryPayment
     * @returns {this}
     */
    setQueryPayment(queryPayment: Hbar): this;
    /**
     * Set the maximum payment allowable for this query.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {this}
     */
    setMaxQueryPayment(maxQueryPayment: Hbar): this;
    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    getCost(client: import("../client/Client.js").default<Channel, any>): Promise<Hbar>;
    /**
     * @param {TransactionId} paymentTransactionId
     * @returns {this}
     */
    setPaymentTransactionId(paymentTransactionId: TransactionId): this;
    /**
     * @returns {?TransactionId}
     */
    get paymentTransactionId(): TransactionId | null;
    /**
     * @protected
     * @returns {boolean}
     */
    protected _isPaymentRequired(): boolean;
    /**
     * @param {Client} client
     */
    _validateChecksums(client: import("../client/Client.js").default<any, any>): void;
    /**
     * @template MirrorChannelT
     * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
     * @returns {Promise<void>}
     */
    _beforeExecute<MirrorChannelT>(client: import("../client/Client.js").default<import("../channel/Channel.js").default, MirrorChannelT>): Promise<void>;
    /**
     * @abstract
     * @internal
     * @param {HashgraphProto.proto.IResponse} response
     * @returns {HashgraphProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response: HashgraphProto.proto.IResponse): HashgraphProto.proto.IResponseHeader;
    /**
     * @protected
     * @returns {HashgraphProto.proto.IQueryHeader}
     */
    protected _makeRequestHeader(): HashgraphProto.proto.IQueryHeader;
    /**
     * @abstract
     * @internal
     * @param {HashgraphProto.proto.IQueryHeader} header
     * @returns {HashgraphProto.proto.IQuery}
     */
    _onMakeRequest(header: HashgraphProto.proto.IQueryHeader): HashgraphProto.proto.IQuery;
    /**
     * @internal
     * @returns {HashgraphProto.proto.IQuery}
     */
    _makeRequest(): HashgraphProto.proto.IQuery;
}
/**
 * @type {((query: Query<*>) => import("./CostQuery.js").default<*>)[]}
 */
export const COST_QUERY: ((query: Query<any>) => import("./CostQuery.js").default<any>)[];
export type Channel = import("../channel/Channel.js").default;
export type PublicKey = import("../PublicKey.js").default;
export type ClientOperator = import("../client/Client.js").ClientOperator;
export type Client = import("../client/Client.js").default<any, any>;
import TransactionId from "../transaction/TransactionId.js";
import AccountId from "../account/AccountId.js";
import Hbar from "../Hbar.js";
import * as HashgraphProto from "@hashgraph/proto";
import Executable from "../Executable.js";
